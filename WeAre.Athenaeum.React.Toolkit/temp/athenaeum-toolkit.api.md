## API Report File for "@weare/athenaeum-toolkit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Dictionary } from 'typescript-collections';

// @public (undocumented)
export const ArrayExtensions: () => void;

// @public (undocumented)
export class ArrayUtility {
    // (undocumented)
    static chunk<TItem>(givenArray: TItem[], chunkSize: number): TItem[][];
    // (undocumented)
    static order<TSource, TKey1, TKey2, TKey3, TKey4, TKey5>(source: TSource[], keySelector1: ((item: TSource) => TKey1), keySelector2?: ((item: TSource) => TKey2), keySelector3?: ((item: TSource) => TKey3), keySelector4?: ((item: TSource) => TKey4), keySelector5?: ((item: TSource) => TKey5)): void;
    // (undocumented)
    static skip<T>(items: readonly T[], count: number): T[];
    // (undocumented)
    static sort<TItem>(first: TItem | any, second: TItem | any, sortingType?: SortDirection | null): number;
    // Warning: (ae-forgotten-export) The symbol "SortDirection" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static sortByProperty<TItem>(propertyName: string, sortDirection?: SortDirection | null): (a: TItem, b: TItem) => number;
    // (undocumented)
    static take<T>(items: readonly T[], count: number): T[];
}

// @public (undocumented)
export class AthenaeumConstants {
    // (undocumented)
    static readonly badRequestStatusCode: number;
    // (undocumented)
    static readonly defaultGuid: string;
    // (undocumented)
    static readonly forbiddenStatusCode: number;
    // (undocumented)
    static readonly internalServerErrorStatusCode: number;
    // (undocumented)
    static readonly markTagRegex: RegExp;
    // (undocumented)
    static readonly newLineRegex: RegExp;
    // (undocumented)
    static readonly notFoundStatusCode: number;
    // (undocumented)
    static readonly okStatusCode: number;
    // (undocumented)
    static readonly smallTagRegex: RegExp;
    // (undocumented)
    static readonly unauthorizedStatusCode: number;
}

// @public (undocumented)
export abstract class BaseEnumProvider<TSelectListItem extends ISelectListItem> implements IEnumProvider, IService {
    protected constructor();
    // (undocumented)
    protected abstract createSelectListItem(value: string, text: string, subtext: string): TSelectListItem;
    // (undocumented)
    getEnumItem(enumName: string, value: any): TSelectListItem;
    // (undocumented)
    getEnumItems(enumName: string, selectedValues?: number[] | null, reverse?: boolean): TSelectListItem[];
    // (undocumented)
    protected getEnumLocalizedDescription(enumType: string, enumName: string): string;
    // (undocumented)
    protected getEnumLocalizedName(enumType: string, enumName: string): string;
    // (undocumented)
    getEnumName(enumName: string, value: any): string;
    // (undocumented)
    getEnumText(enumName: string, value: any): string;
    // (undocumented)
    protected getItems(enumSymbol: any, enumType: string, reverse?: boolean): TSelectListItem[];
    // (undocumented)
    getType(): ServiceType;
    // (undocumented)
    getValues(enumSymbol: any, reverse?: boolean): number[];
    // (undocumented)
    isEnum(typeName: string): boolean;
    // (undocumented)
    protected get localizer(): ILocalizer;
    // (undocumented)
    protected transform(enumSymbol: any, enumType: string, enumValue: any): TSelectListItem;
    // (undocumented)
    protected abstract get types(): readonly string[];
}

// @public (undocumented)
export abstract class BaseLocalizer implements ILocalizer, IService {
    protected constructor(supportedLanguages: ILanguage[], language: string);
    // (undocumented)
    contains(name: string): boolean;
    // (undocumented)
    get defaultLanguage(): string;
    // (undocumented)
    findLanguage(language: string | null | undefined): ILanguage;
    // (undocumented)
    get(name: string | null | undefined, ...params: (string | number | boolean | Date | null | undefined)[]): string;
    // (undocumented)
    protected getLanguageItems(language: string): Dictionary<string, string>;
    // (undocumented)
    getType(): ServiceType;
    // (undocumented)
    get language(): string;
    // (undocumented)
    protected set(name: string, ...params: {
        language: string;
        value: string;
    }[]): void;
    // (undocumented)
    protected setItem(name: string, language: string, value: string): void;
    // (undocumented)
    setLanguage(language: string): boolean;
    // (undocumented)
    get supportedLanguageCodes(): string[];
    // (undocumented)
    get supportedLanguages(): ILanguage[];
    }

// @public (undocumented)
export abstract class BaseTransformProvider implements ITransformProvider, IService {
    protected constructor();
    // (undocumented)
    getType(): ServiceType;
    // (undocumented)
    locationToString(location: GeoLocation | null): string;
    // (undocumented)
    toString(item: any, format?: TFormat | null): string;
}

// @public (undocumented)
export class BoolUtility {
    // (undocumented)
    static compare(x: boolean, y: boolean, inverse?: boolean): number;
}

// @public (undocumented)
export const DateExtensions: () => void;

// @public (undocumented)
export class DateUtility {
    // (undocumented)
    static compare(x: Date | string, y: Date | string, inverse?: boolean): number;
    // (undocumented)
    static equals(x: Date | string, y: Date | string): boolean;
}

// @public (undocumented)
export class FileModel {
    constructor(src?: string | null);
    // (undocumented)
    id: string;
    // (undocumented)
    readonly isFileModel: boolean;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    name: string;
    // (undocumented)
    size: number;
    // (undocumented)
    src: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export class GeoCoordinate {
    constructor(latitude?: number | null | undefined, longitude?: number | null | undefined);
    // (undocumented)
    isGeoCoordinate: boolean;
    // (undocumented)
    lat: number;
    // (undocumented)
    lon: number;
}

// @public (undocumented)
export class GeoLocation extends GeoCoordinate {
    // (undocumented)
    address: string;
    // (undocumented)
    city: string;
    // (undocumented)
    country: string;
    // (undocumented)
    formattedAddress: string;
    // (undocumented)
    isGeoLocation: boolean;
    // (undocumented)
    postalBox: string;
    // (undocumented)
    postalCode: string;
}

// @public (undocumented)
export class HashCodeUtility {
    // (undocumented)
    static getBooleanHashCode(value: boolean): number;
    // (undocumented)
    static getDateHashCode(value: Date): number;
    static getHashCode(value: any | null | undefined): number;
    // (undocumented)
    static getNumberHashCode(value: number): number;
    // (undocumented)
    static getStringHashCode(value: string): number;
    }

// @public (undocumented)
export interface IEnumProvider {
    // (undocumented)
    getEnumText(enumName: string, value: any): string;
    // (undocumented)
    isEnum(typeName: string): boolean;
}

// @public (undocumented)
export interface ILanguage {
    // (undocumented)
    readonly code: string;
    // (undocumented)
    readonly label: string;
}

// @public (undocumented)
export interface ILocalizer {
    // (undocumented)
    contains(name: string): boolean;
    // (undocumented)
    get(name: string | null | undefined, ...params: (string | number | boolean | Date | null | undefined)[]): string;
    // (undocumented)
    setLanguage(language: string): boolean;
}

// @public (undocumented)
export interface INumberFormat {
    // (undocumented)
    format: TFormat;
    // (undocumented)
    step: number;
}

// @public (undocumented)
export interface IPagedList<T = {}> {
    // (undocumented)
    items: T[];
    // (undocumented)
    pageCount: number;
    // (undocumented)
    pageNumber: number;
    // (undocumented)
    pageSize: number;
    // (undocumented)
    totalItemCount: number;
}

// @public (undocumented)
export interface ISelectListItem {
    // (undocumented)
    disabled: boolean;
    // (undocumented)
    selected: boolean;
    // (undocumented)
    text: string;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export interface IService {
    getType(): ServiceType;
}

// @public (undocumented)
export interface ITransformProvider {
    // (undocumented)
    toString(item: any, format?: TFormat | null): string;
}

// @public (undocumented)
export const NumberExtensions: () => void;

// @public (undocumented)
export class NumberParsingResult {
    constructor(value?: number | null | undefined);
    // (undocumented)
    acceptableStr: string | null;
    // (undocumented)
    inputStr: string;
    // (undocumented)
    parsed: boolean;
    // (undocumented)
    value: number;
    // (undocumented)
    valueStr: string;
}

// @public (undocumented)
export class NumberUtility {
    // (undocumented)
    static compare(x: number, y: number, inverse?: boolean): number;
    // (undocumented)
    static parse(str: string, allowFloat?: boolean, maxLength?: number): NumberParsingResult;
    // (undocumented)
    static resolveFormat(step: number | null | undefined, format: TFormat | null | undefined, defaultFormat?: string | null | undefined): INumberFormat;
}

// Warning: (ae-forgotten-export) The symbol "PwaHelper" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const PwaHelper: PwaHelper_2;

// Warning: (ae-forgotten-export) The symbol "ServiceProvider" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ServiceProvider: ServiceProvider_2;

// @public (undocumented)
export type ServiceType = string;

// @public (undocumented)
export const StringExtensions: () => void;

// @public (undocumented)
export class StringUtility {
    // (undocumented)
    static compare(x: string, y: string, inverse?: boolean): number;
}

// Warning: (ae-forgotten-export) The symbol "TStringTransformer" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type TFormat = string | TStringTransformer;

// @public (undocumented)
export class TimeSpan {
    constructor(days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number);
    add(ts: TimeSpan): TimeSpan;
    static compare(t1: TimeSpan, t2: TimeSpan): number;
    compareTo(value: TimeSpan): number;
    get days(): number;
    equals(obj: TimeSpan): boolean;
    static equals(t1: TimeSpan, t2: TimeSpan): boolean;
    static fromDays(days: number): TimeSpan;
    static fromHours(hours: number): TimeSpan;
    static fromMilliseconds(milliseconds: number): TimeSpan;
    static fromMinutes(minutes: number): TimeSpan;
    static fromSeconds(seconds: number): TimeSpan;
    getHashCode(): number;
    get hours(): number;
    get milliseconds(): number;
    // (undocumented)
    static readonly millisecondsPerDay: number;
    // (undocumented)
    static readonly millisecondsPerHour: number;
    // (undocumented)
    static readonly millisecondsPerMinute: number;
    // (undocumented)
    static readonly millisecondsPerSecond: number;
    get minutes(): number;
    multiply(factor: number): TimeSpan;
    negate(): TimeSpan;
    get seconds(): number;
    subtract(ts: TimeSpan): TimeSpan;
    // (undocumented)
    toShortTimeString(): string;
    get totalDays(): number;
    get totalHours(): number;
    get totalMilliseconds(): number;
    get totalMinutes(): number;
    get totalSeconds(): number;
    // (undocumented)
    toTimeString(): string;
}

// @public (undocumented)
export class Utility {
    // (undocumented)
    static addDays(date: Date | string, days: number): Date;
    // (undocumented)
    static addMonths(date: Date | string, months: number): Date;
    // (undocumented)
    static asUtc(date: Date | string): Date;
    // (undocumented)
    static base64FromDataUrl(dataUrl: string): string;
    static clickedOutside(target: Node, id: string, exceptId?: string | null, exceptTag?: string | null): boolean;
    // (undocumented)
    static clone(object: any): any;
    // (undocumented)
    static copyTo(from: Dictionary<string, any> | any, ...to: any[]): void;
    // (undocumented)
    static count<T>(items: readonly T[] | null | undefined, callback: (item: T, index: number) => boolean): number;
    // (undocumented)
    static css(...params: (readonly string[] | string | null | undefined | false)[]): string;
    // (undocumented)
    static date(): Date;
    // (undocumented)
    static diff(x: Date | string, y: Date | string, ignoreTimeZone?: boolean): TimeSpan;
    // (undocumented)
    static distance(x: Position, y: GeoCoordinate): number;
    // (undocumented)
    static distinct<T>(items: readonly T[], callback?: ((item: T) => any) | null | undefined): T[];
    // (undocumented)
    static findStringValueByAccessor(instance: any, accessor: string | ReadonlyArray<string>): string | null;
    // (undocumented)
    static findValueByAccessor(instance: any, accessor: string | readonly string[]): any | null | undefined;
    // (undocumented)
    static forEachAsync<T>(items: readonly T[], callback: (item: T) => Promise<void>): Promise<void>;
    // (undocumented)
    static format(text: string | null | undefined, ...params: (string | number | boolean | Date | null | undefined | any)[]): string;
    // (undocumented)
    static formatValue(value: any, format: TFormat | null | undefined): string;
    // (undocumented)
    static get geoEnabled(): boolean;
    // (undocumented)
    static getDateWithoutTime(date: Date | string): Date;
    // (undocumented)
    static getDayOfWeek(dayOfWeekOrDate: number | Date | string): string;
    // (undocumented)
    static getDaysInMonth(date: Date): number;
    // (undocumented)
    static getExtensionsFromMimeTypes(mimeTypes: string[]): string;
    // (undocumented)
    static getHashCode(value: any | null | undefined): number;
    // (undocumented)
    static getLocationAsync(options?: PositionOptions | null | undefined): Promise<GeoCoordinate | null>;
    // (undocumented)
    static getMonth(monthOrDate: number | Date | string): string;
    // (undocumented)
    static getPositionAsync(options?: PositionOptions | null | undefined): Promise<Position | null>;
    // (undocumented)
    static getShortDayOfWeek(dayOfWeekOrDate: number | Date | string): string;
    // (undocumented)
    static getShortMonth(monthOrDate: number | Date | string): string;
    // (undocumented)
    static groupBy<T>(items: readonly T[], callback?: ((item: T) => any) | null | undefined): T[][];
    // (undocumented)
    static inFuture(date: Date | string | null): boolean;
    // (undocumented)
    static inInterval(date: Date | string, from: Date | string | null | undefined, to: Date | string | null | undefined): boolean;
    // (undocumented)
    static inPast(date: Date | string | null): boolean;
    // (undocumented)
    static isDateType(date: any): boolean;
    // (undocumented)
    static isLeapYear(year?: number | null): boolean;
    // (undocumented)
    static isSunday(date: Date | string): boolean;
    // (undocumented)
    static isToday(date: Date | string): boolean;
    // (undocumented)
    static max<T>(items: readonly T[], callback?: ((item: T) => number) | null): T;
    // (undocumented)
    static maxValue<T>(items: readonly T[], callback: (item: T) => number): number;
    // (undocumented)
    static min<T, TValue = number | Date>(items: readonly T[], callback?: ((item: T) => TValue) | null): T;
    // (undocumented)
    static minValue<T, TValue = number | Date>(items: readonly T[], callback: (item: T) => TValue): TValue;
    // (undocumented)
    static now(): Date;
    // (undocumented)
    static pad(value: number): string;
    // (undocumented)
    static readUploadedFileAsArrayBuffer(inputFile: File): Promise<ArrayBuffer>;
    // (undocumented)
    static readUploadedFileAsBinaryString(inputFile: File): Promise<string>;
    // (undocumented)
    static readUploadedFileAsDataUrl(inputFile: File): Promise<string>;
    // (undocumented)
    static remove<T>(items: T[], item: T | []): void;
    // (undocumented)
    static removeAt<T>(items: T[], index: number): void;
    // (undocumented)
    static restoreDate(model: any, path?: string): any;
    // (undocumented)
    static round(value: number, digits?: number): number;
    // (undocumented)
    static roundE(value: number): number;
    // (undocumented)
    static roundHalf(value: number): number;
    // (undocumented)
    static selectMany<TIn, TOut>(items: TIn[], collectionSelector: (item: TIn) => TOut[]): TOut[];
    // (undocumented)
    static setTimeout(asyncCallback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;
    // (undocumented)
    static setValueByAccessor(instance: any, accessor: string, value: any): void;
    // (undocumented)
    static sum<T>(items: readonly T[] | null | undefined, callback: (item: T) => number | null | undefined): number;
    // (undocumented)
    static get timezoneOffset(): number;
    // (undocumented)
    static toCurrencyString(input: number): string;
    // (undocumented)
    static toDateShortTimeString(date: Date | string): string;
    // (undocumented)
    static toDateString(date: Date | string): string;
    // (undocumented)
    static toDateTimeString(date: Date): string;
    // (undocumented)
    static today(): Date;
    // (undocumented)
    static toISODateString(date: Date): string;
    // (undocumented)
    static toLocal(date: Date | string): Date;
    // (undocumented)
    static toLongISOString(date: Date): string;
    // (undocumented)
    static tomorrow(): Date;
    // (undocumented)
    static toPagedList<T>(items: readonly T[], pageNumber: number, pageSize: number): IPagedList<T>;
    // (undocumented)
    static toShortTimeString(date: Date): string;
    // (undocumented)
    static toTimeString(date: Date | string): string;
    // (undocumented)
    static toUtc(date: Date | string): Date;
    // (undocumented)
    static transformFileAsync(fileReference: File | null): Promise<FileModel | null>;
    // (undocumented)
    static utcNow(): Date;
    // (undocumented)
    static utcValueOf(date: Date | string): number;
    // (undocumented)
    static wait(ms: number): Promise<NodeJS.Timeout>;
    // (undocumented)
    static where<T>(items: readonly T[], predicate: (item: T) => boolean): T[];
    // (undocumented)
    static whereAsync<T>(items: readonly T[], callback: (item: T) => Promise<boolean>): Promise<T[]>;
}


// (No @packageDocumentation comment for this package)

```
